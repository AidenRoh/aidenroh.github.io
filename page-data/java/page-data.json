{"componentChunkName":"component---src-templates-post-jsx","path":"/java/","result":{"data":{"site":{"siteMetadata":{"title":"DevAiden"}},"markdownRemark":{"id":"751ad2bd-5825-588d-8658-9b64bfc7cf1b","excerpt":"내가 처음 백엔드를 시작했을 때 느낀 점과 오늘 2023년 \"Code State\"라는 부트캠프에서 side project를 진행하던 당시, 한 팀원과 작은 마찰이 있었던 것이 기억난다. 마찰이 생긴 원인은 이러했다: 백엔드를 처음 배우고 있는 우리가, 잘하는 사람이 짜놓은 코드의 흐름에 중점을 두고 이해하고 넘어가는 것이 좋은 것일까 아니면, 기저에 있는…","html":"<h2>내가 처음 백엔드를 시작했을 때 느낀 점과 오늘</h2>\n<p>2023년 \"Code State\"라는 부트캠프에서 side project를 진행하던 당시, 한 팀원과 작은 마찰이 있었던 것이 기억난다. 마찰이 생긴 원인은 이러했다: 백엔드를 처음 배우고 있는 우리가, 잘하는 사람이 짜놓은 코드의 흐름에 중점을 두고 이해하고 넘어가는 것이 좋은 것일까 아니면, 기저에 있는 지식을 채워가면서 공부하는 것이 좋은 것일까? 난 후자가 옳다고 생각했다. 영어가 항상 장애물이었던 내 고교 시절의 경험을 생각한다면, 단순히 노출을 많이 시키는 것으론 정확한 개념을 체득할 수 없다는 것이 내가 가지고 있는 학습에 대한 공리였다. Java 문법을 공부하고 객체지향의 개념을 알아 갈수록 Spring에 대한 이해도 또한 조금씩 올라가는 것을 느끼게 된다.</p>\n<p>그리고 블로깅을 할 수 있겠다는 자신감이 생겼다. 블로그를 통해 내 학습과 사고의 방향을 구체적으로 남기고 싶다. Spring에 대한 이해를 시작으로 백엔드 개발자가 되기까지, 되고 난 후의 여정을 담고자 한다!</p>\n<h2>What is Core Value of Spring?</h2>\n<blockquote>\n<p>Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment.</p>\n</blockquote>\n<p>Spring은 Java 애플리케이션을 쉽게 개발할 수 있게 만든 프레임워크라고 말한다. 그렇기에 스프링의 핵심은 다음과 같다.</p>\n<ul>\n<li>Spring은 Java 언어 기반의 프레임워크 (<strong>POJO</strong>)</li>\n<li>Java은 객체 지향 언어 (<strong>OOP</strong>)</li>\n<li>Spring은 OOP의 특징을 잘 살려낸 프레임워크</li>\n<li>그렇기에 위에서 말한 Java enterprise application은 좋은 객체 지향으로 설계할 수 있게 하는 프레임워크</li>\n</ul>\n<p>Spring을 공부하기 전에, 좋은 객체지향이란 무엇이고 Java는 어떻게 좋은 객체지향 설계를 할 수 있는지 알아가는 것이 좋을 것이다.</p>\n<h2>객체 지향과 그 특징 (OOP)</h2>\n<blockquote>\n<p>컴퓨터 프로그래밍을 독립된 단위, 즉 \"객체\"들의 모임으로 각각의 객체가 메시지를 주고 받고 데이터를 처리할 수 있게 설계하는 방식</p>\n</blockquote>\n<p>이러한 객체 지향 설계는 프로그램을 유연하고 변경이 용이하게 만들어준다. 그런 객체 지향은 4가지 특징이 있다.</p>\n<ul>\n<li>추상화</li>\n<li>캡슐화</li>\n<li>상속</li>\n<li><strong>다형성</strong></li>\n</ul>\n<p>이 4가지 특징 중 가장 중요한 특징이 \"다형성\"일 것이다.</p>\n<h2>다형성</h2>\n<p>다형성은 <strong>역할</strong>과 <strong>구현</strong>으로 세상을 구분 하는 것이 핵심이다. 다형성은 2가지 핵심 이론을 통해 만들어진다.</p>\n<ul>\n<li>다형적 참조</li>\n<li>메서드 오버라이딩</li>\n</ul>\n<h3>다형적 참조</h3>\n<p>부모 클래스와 자식 클래스 (상속 관계에 있는 두 클래스)가 주어졌을 때, 부모는 자식을 품을 수 있는 것이 다형적 참조이다.</p>\n<p>e.g.1 <code class=\"language-text\">Parent poly = new Child();</code></p>\n<p>부모가 자식을 담을 수 있는 이유는 자식 클래스가 부모 클래스를 상속했기 때문이다. <code class=\"language-text\">Child</code> 인스턴스가 생성될 시, 해당 인스턴스엔 상속에 의해 <code class=\"language-text\">Parent</code> 인스턴스 또한 생성된다. </p>\n<p>e.g.2 <code class=\"language-text\">poly.parentMethod();</code></p>\n<p>위의 첫 번째 예시처럼 다형적 참조를 하게 되면, <code class=\"language-text\">poly.parentMethod();</code>를 실행할 때, <code class=\"language-text\">Child</code>클래스의 인스턴스에서 <code class=\"language-text\">Parent</code>타입으로 된 \"parentMethod()\"가 있는지 우선 탐색을 하게되고 있다면 해당 메서드를 실행하게 된다.</p>\n<p>--</p>\n<p>나만의 이해 방식을 도입해보자면, 일본 애니메이션 <strong>진격의 거인</strong>이 떠오른다. 부모 클래스가 7대 거인 중 하나라고 생각하고 자식 클래스가 그 거인을 계승한 에르디아인이라고 생각해보자.</p>\n<p>e.g.3 <code class=\"language-text\">진격의 거인 titan = new ErenJaeger();</code></p>\n<p>에렌이 진격의 거인을 상속(계승)했기 때문에, 에렌은 진격의 거인이라고 보는 것에 어색함이 없다. 그리고 에렌은 진격의 거인이 가지고 있는 내부의 힘 (인스턴스 값)을 가지고 있는 것이다.</p>\n<hr>\n<h3>메서드 오버라이딩</h3>\n<p>\"다형적 참조\"를 통해 특정 메서드를 실행할 때, 부모 타입의 객체와 자식 타입의 객체에 같은 이름으로 된 메서드가 존재한다고 생각해보자, 무엇이 우선순위가 될까? </p>\n<p>당연히 다형적 참조에 선언된 타입이 우선순위가 된다. e.g.1 의 예시같은 경우 Parent 타입의 메서드가 우선순위가 되는 것이다. 하지만 이 우선순위를 강제로 바꿀 수 있는 방법이 있는데, 이것이 <strong>메서드 오버라이딩</strong>이다. 자식 타입 클래스에서 메서드 오버라이딩을 하는 순간, 메서드 호출 시 오버라이딩된 타입의 메서드가 최우선순위가 된다.</p>\n<p>--</p>\n<p>메서드 오버라이딩 또한 비슷한 비유를 들 수 있다. </p>\n<p>e.g.4 <code class=\"language-text\">짐승의 거인 titan = new FalcoGrice();</code></p>\n<p>짐승의 거인은 팔코가 계승하게 되었을 때를 생각해보자, 원숭이 형상과 비슷했던 짐승의 거인은 팔코가 계승했을 때, 날개를 가진 새의 형상을 가지고 있었다. 그렇다면 다음과 같은 상관 관계이지 않을까 생각한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class 짐승의 거인 {\n\n  String 계승자;\n\n  public void 짐승형태(){};\n}\n\nclass FalcoGrice extends 짐승의 거인 {\n\n  @override\n  public void 짐승형태(){\n    system.out.print(\"새\");\n  }\n}</code></pre></div>\n<p>짐승의 거인을 계승한 사람이 팔코이기에 팔코만의 커스터마이징 짐승 형태 메서드가 최우선순위가 되는 것이다.</p>\n<hr>\n<h3>다형성의 본질</h3>\n<ul>\n<li>인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.</li>\n<li>역할과 구현의 분리를 가능하게 한다.</li>\n<li>클라이언트의 코드 변경 없이, 서버의 구현을 유연하게 변경할 수 있다.</li>\n</ul>\n<p>다형성이란 역할과 구현을 분리시켜준 다는 것에 큰 의미가 있는 것 같다. </p>\n<p>진격의 거인이라는 역할과 그것을 구현하는 에렌을 가능하게 하는 것이 프로그램 세계의 다형성인 것이다! 계승자가 바뀐다고 해서 진격의 거인이란 능력이 바뀌지 않듯이! 거인화라는 클라이언트 코드의 변경 없이 짐승형 거인이 지크에서 팔코로 유연하게 변경될 수 있었다.</p>\n<h2>SOLID 법칙</h2>\n<p>좋은 객체 지향 설계에 빠지지 않고 나오는 법칙이다.</p>\n<ul>\n<li>SRP (Single Responsibility Principle) : 한 클래스는 프로젝트의 중요한 기준에 따라 하나의 책임을 가져야한다. </li>\n<li>OCP (Open/Closed Principle) : 확장에는 열려있으나 변경에는 닫혀있어야 한다.</li>\n<li>LSP (Liskov Substitution Principle) : 다형성에서 하위클래스(자식클래스)는 인터페이스 규약을 다 지켜야 한다.</li>\n<li>ISP (Interface Segregation Principle) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. SRP와 비슷한 맥락으로 생각됩니다.</li>\n<li>DIP (Dependency Inversion Principle) : 구체화(구현 클래스)에 의존하는 것이 아닌, 추상화(인터페이스)에 의존한다.</li>\n</ul>\n<p>단순한 다형성 만으론 OCP와 DIP 원칙이 위배되는 경우가 많다. </p>\n<p>e.g.5 <code class=\"language-text\">MemberRepository mr = new MemoryMemberRepository();</code></p>\n<p>와 같이 구현 객체 내에 인터페이스 \"MemberRepository\"에 구현 객체인 \"MemoryMemberRepository\"를 주입하는 경우. Spring은 DI (Dependency Injection), IoC(Inversion of Control) 기술을 통해 OCP 와 DIP 원칙을 쉽게 가능하게 지원해준다. </p>","frontmatter":{"title":"스프링을 공부하기 전에 알아야할 기반 지식은 뭘까?","date":"February 22, 2024","update":"March 01, 2024","tags":["Spring","Java"],"series":"Java Spring Series"},"fields":{"slug":"/java/","readingTime":{"minutes":10.165}}},"seriesList":{"edges":[{"node":{"id":"751ad2bd-5825-588d-8658-9b64bfc7cf1b","fields":{"slug":"/java/"},"frontmatter":{"title":"스프링을 공부하기 전에 알아야할 기반 지식은 뭘까?"}}}]},"previous":{"fields":{"slug":"/about-hoodie/"},"frontmatter":{"title":"🎇 1. About gatsby-starter-hoodie"}},"next":null},"pageContext":{"id":"751ad2bd-5825-588d-8658-9b64bfc7cf1b","series":"Java Spring Series","previousPostId":"05b7f40a-6d43-58c5-bfbb-6f17f9571a25","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}