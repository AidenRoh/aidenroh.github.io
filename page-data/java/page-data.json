{"componentChunkName":"component---src-templates-post-jsx","path":"/java/","result":{"data":{"site":{"siteMetadata":{"title":"DevAiden"}},"markdownRemark":{"id":"751ad2bd-5825-588d-8658-9b64bfc7cf1b","excerpt":"내가 처음 백엔드를 시작했을 때 느낀 점과 오늘 2023년 \"Code State\"라는 부트캠프에서 side project를 진행하던 당시, 한 팀원과 작은 마찰이 있었던 것이 기억난다. 마찰이 생긴 원인은 이러했다: 백엔드를 처음 배우고 있는 우리가, 잘하는 사람이 짜놓은 코드의 흐름에 중점을 두고 이해하고 넘어가는 것이 좋은 것일까 아니면, 기저에 있는…","html":"<h2>내가 처음 백엔드를 시작했을 때 느낀 점과 오늘</h2>\n<p>2023년 \"Code State\"라는 부트캠프에서 side project를 진행하던 당시, 한 팀원과 작은 마찰이 있었던 것이 기억난다. 마찰이 생긴 원인은 이러했다: 백엔드를 처음 배우고 있는 우리가, 잘하는 사람이 짜놓은 코드의 흐름에 중점을 두고 이해하고 넘어가는 것이 좋은 것일까 아니면, 기저에 있는 지식을 채워가면서 공부하는 것이 좋은 것일까? 난 후자가 옳다고 생각했다. 영어가 항상 장애물이었던 내 고교 시절의 경험을 생각한다면, 단순히 노출을 많이 시키는 것으론 정확한 개념을 체득할 수 없다는 것이 내가 가지고 있는 학습에 대한 공리였다. Java 문법을 공부하고 객체지향의 개념을 알아 갈수록 Spring에 대한 이해도 또한 조금씩 올라가는 것을 느끼게 된다.</p>\n<p>그리고 블로깅을 할 수 있겠다는 자신감이 생겼다. 블로그를 통해 내 학습과 사고의 방향을 구체적으로 남기고 싶다. Spring에 대한 이해를 시작으로 백엔드 개발자가 되기까지, 되고 난 후의 여정을 담고자 한다!</p>\n<h2>What is Core Value of Spring?</h2>\n<blockquote>\n<p>Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment.</p>\n</blockquote>\n<p>Spring은 Java 애플리케이션을 쉽게 개발할 수 있게 만든 프레임워크라고 말한다. 그렇기에 스프링의 핵심은 다음과 같다.</p>\n<ul>\n<li>Spring은 Java 언어 기반의 프레임워크 (<strong>POJO</strong>)</li>\n<li>Java은 객체 지향 언어 (<strong>OOP</strong>)</li>\n<li>Spring은 OOP의 특징을 잘 살려낸 프레임워크</li>\n<li>그렇기에 위에서 말한 Java enterprise application은 좋은 객체 지향으로 설계할 수 있게 하는 프레임워크</li>\n</ul>\n<p>Spring을 공부하기 전에, 좋은 객체지향이란 무엇이고 Java는 어떻게 좋은 객체지향 설계를 할 수 있는지 알아가는 것이 좋을 것이다.</p>\n<h2>객체 지향과 그 특징 (OOP)</h2>\n<blockquote>\n<p>컴퓨터 프로그래밍을 독립된 단위, 즉 \"객체\"들의 모임으로 각각의 객체가 메시지를 주고 받고 데이터를 처리할 수 있게 설계하는 방식</p>\n</blockquote>\n<p>이러한 객체 지향 설계는 프로그램을 유연하고 변경이 용이하게 만들어준다. 그런 객체 지향은 4가지 특징이 있다.</p>\n<ul>\n<li>추상화</li>\n<li>캡슐화</li>\n<li>상속</li>\n<li><strong>다형성</strong></li>\n</ul>\n<p>이 4가지 특징 중 가장 중요한 특징이 \"다형성\"일 것이다.</p>\n<h2>다형성</h2>\n<p>다형성은 <strong>역할</strong>과 <strong>구현</strong>으로 세상을 구분 하는 것이 핵심이다. 다형성은 2가지 핵심 이론을 통해 만들어진다.</p>\n<ul>\n<li>다형적 참조</li>\n<li>메서드 오버라이딩</li>\n</ul>\n<h3>다형적 참조</h3>\n<p>부모 클래스와 자식 클래스 (상속 관계에 있는 두 클래스)가 주어졌을 때, 부모는 자식을 품을 수 있는 것이 다형적 참조이다.</p>\n<p>e.g.1 <code class=\"language-text\">Parent poly = new Child();</code></p>\n<p>부모가 자식을 담을 수 있는 이유는 자식 클래스가 부모 클래스를 상속했기 때문이다. <code class=\"language-text\">Child</code> 인스턴스가 생성될 시, 해당 인스턴스엔 상속에 의해 <code class=\"language-text\">Parent</code> 인스턴스 또한 생성된다. </p>\n<p>e.g.2 <code class=\"language-text\">poly.parentMethod();</code></p>\n<p>위의 첫 번째 예시처럼 다형적 참조를 하게 되면, <code class=\"language-text\">poly.parentMethod();</code>를 실행할 때, <code class=\"language-text\">Child</code>클래스의 인스턴스에서 <code class=\"language-text\">Parent</code>타입으로 된 \"parentMethod()\"가 있는지 우선 탐색을 하게되고 있다면 해당 메서드를 실행하게 된다.</p>\n<hr>\n<h3>메서드 오버라이딩</h3>\n<p>\"다형적 참조\"를 통해 특정 메서드를 실행할 때, 부모 타입의 객체와 자식 타입의 객체에 같은 이름으로 된 메서드가 존재한다고 생각해보자, 무엇이 우선순위가 될까? </p>\n<p>당연히 다형적 참조에 선언된 타입이 우선순위가 된다. e.g.1 의 예시같은 경우 Parent 타입의 메서드가 우선순위가 되는 것이다. 하지만 이 우선순위를 강제로 바꿀 수 있는 방법이 있는데, 이것이 <strong>메서드 오버라이딩</strong>이다. 자식 타입 클래스에서 메서드 오버라이딩을 하는 순간, 메서드 호출 시 오버라이딩된 타입의 메서드가 최우선순위가 된다.</p>\n<hr>\n<p>이 두 핵심 이론을 통해 변화에 용이한 객체 지향 설계, 즉 역할과 구현이 분리된 설계가 가능해진다. 부모 타입이 역할, 자식 타입이 구현이라고 생각해보자. 부모 타입으로 특정 메서드를 실행하지만, 자식 타입의 메서드가 호출되는 것. </p>\n<h3>SOLID 법칙</h3>\n<p>좋은 객체 지향 설계에 빠지지 않고 나오는 법칙이다.</p>","frontmatter":{"title":"What is Spring framework","date":"February 22, 2024","update":"March 01, 2024","tags":["Spring","Java"],"series":"Java Spring Series"},"fields":{"slug":"/java/","readingTime":{"minutes":6.39}}},"seriesList":{"edges":[{"node":{"id":"751ad2bd-5825-588d-8658-9b64bfc7cf1b","fields":{"slug":"/java/"},"frontmatter":{"title":"What is Spring framework"}}}]},"previous":{"fields":{"slug":"/about-hoodie/"},"frontmatter":{"title":"🎇 1. About gatsby-starter-hoodie"}},"next":null},"pageContext":{"id":"751ad2bd-5825-588d-8658-9b64bfc7cf1b","series":"Java Spring Series","previousPostId":"05b7f40a-6d43-58c5-bfbb-6f17f9571a25","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}