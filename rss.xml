<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of DevAiden]]></title><description><![CDATA[Hello :) I'm Aiden.]]></description><link>https://aidenroh.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 01 Mar 2024 15:06:50 GMT</lastBuildDate><item><title><![CDATA[What is Spring framework]]></title><description><![CDATA[내가 처음 백엔드를 시작했을 때 느낀 점과 오늘 2023년 "Code State"라는 부트캠프에서 side project…]]></description><link>https://aidenroh.github.io/java/</link><guid isPermaLink="false">https://aidenroh.github.io/java/</guid><pubDate>Thu, 22 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;내가 처음 백엔드를 시작했을 때 느낀 점과 오늘&lt;/h2&gt;
&lt;p&gt;2023년 &quot;Code State&quot;라는 부트캠프에서 side project를 진행하던 당시, 한 팀원과 작은 마찰이 있었던 것이 기억난다. 마찰이 생긴 원인은 이러했다: 백엔드를 처음 배우고 있는 우리가, 잘하는 사람이 짜놓은 코드의 흐름에 중점을 두고 이해하고 넘어가는 것이 좋은 것일까 아니면, 기저에 있는 지식을 채워가면서 공부하는 것이 좋은 것일까? 난 후자가 옳다고 생각했다. 영어가 항상 장애물이었던 내 고교 시절의 경험을 생각한다면, 단순히 노출을 많이 시키는 것으론 정확한 개념을 체득할 수 없다는 것이 내가 가지고 있는 학습에 대한 공리였다. Java 문법을 공부하고 객체지향의 개념을 알아 갈수록 Spring에 대한 이해도 또한 조금씩 올라가는 것을 느끼게 된다.&lt;/p&gt;
&lt;p&gt;그리고 블로깅을 할 수 있겠다는 자신감이 생겼다. 블로그를 통해 내 학습과 사고의 방향을 구체적으로 남기고 싶다. Spring에 대한 이해를 시작으로 백엔드 개발자가 되기 까지, 되고 난 후의 여정을 담고자 한다!&lt;/p&gt;
&lt;h2&gt;What is Core Value of Spring?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring은 Java 애플리케이션을 쉽게 개발할 수 있게 만든 프레임워크라고 말하고 있다. 그렇기에 스프링의 핵심은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring은 Java 언어 기반의 프레임워크 (&lt;strong&gt;POJO&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Java은 객체 지향 언어 (&lt;strong&gt;OOP&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Spring은 OOP의 특징을 잘 살려낸 프레임워크&lt;/li&gt;
&lt;li&gt;그렇기에 위에서 말한 Java enterprise application은 좋은 객체 지향으로 설계할 수 있게 하는 프레임워크&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring을 공부하기 전에, 좋은 객체지향이란 무엇이고 Java는 어떻게 좋은 객체지향 설계를 할 수 있는지 알아가는 것이 좋을 것이다.&lt;/p&gt;
&lt;h2&gt;객체 지향과 그 특징 (OOP)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;컴퓨터 프로그래밍을 독립된 단위, 즉 &quot;객체&quot;들의 모임으로 각각의 객체가 메시지를 주고 받고 데이터를 처리할 수 있게 설계하는 방식&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 객체 지향 설계는 프로그램을 유연하고 변경이 용이하게 만들어준다. 그런 객체 지향은 4가지 특징이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추상화&lt;/li&gt;
&lt;li&gt;캡슐화&lt;/li&gt;
&lt;li&gt;상속&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다형성&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 4가지 특징 중 가장 중요한 특징이 &quot;다형성&quot;일 것이다.&lt;/p&gt;
&lt;h2&gt;다형성&lt;/h2&gt;
&lt;p&gt;다형성은 &lt;strong&gt;역할&lt;/strong&gt;과 &lt;strong&gt;구현&lt;/strong&gt;으로 세상을 구분 하는 것이 핵심이다. 다형성은 2가지 핵심 이론을 통해 만들어진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다형적 참조&lt;/li&gt;
&lt;li&gt;메서드 오버라이딩&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;다형적 참조&lt;/h3&gt;
&lt;p&gt;부모 클래스와 자식 클래스 (상속 관계에 있는 두 클래스)가 주어졌을 때, 부모는 자식을 품을 수 있는 것이 다형적 참조이다.&lt;/p&gt;
&lt;p&gt;e.g.1 &lt;code class=&quot;language-text&quot;&gt;Parent poly = new Child();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;부모가 자식을 담을 수 있는 이유는 자식 클래스가 부모 클래스를 상속했기 때문이다. &lt;code class=&quot;language-text&quot;&gt;Child&lt;/code&gt; 인스턴스가 생성될 시, 해당 인스턴스엔 상속에 의해 &lt;code class=&quot;language-text&quot;&gt;Parent&lt;/code&gt; 인스턴스 또한 생성된다. &lt;/p&gt;
&lt;p&gt;e.g.2 &lt;code class=&quot;language-text&quot;&gt;poly.parentMethod();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;위의 첫 번째 예시처럼 다형적 참조를 하게 되면, &lt;code class=&quot;language-text&quot;&gt;poly.parentMethod();&lt;/code&gt;를 실행할 때, &lt;code class=&quot;language-text&quot;&gt;Child&lt;/code&gt;클래스의 인스턴스에서 &lt;code class=&quot;language-text&quot;&gt;Parent&lt;/code&gt;타입으로 된 &quot;parentMethod()&quot;가 있는지 우선 탐색을 하게되고 있다면 해당 메서드를 실행하게 된다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;메서드 오버라이딩&lt;/h3&gt;
&lt;p&gt;&quot;다형적 참조&quot;를 통해 특정 메서드를 실행할 때, 부모 타입의 객체와 자식 타입의 객체에 같은 이름으로 된 메서드가 존재한다고 생각해보자, 무엇이 우선순위가 될까? &lt;/p&gt;
&lt;p&gt;당연히 다형적 참조에 선언된 타입이 우선순위가 된다. e.g.1 의 예시같은 경우 Parent 타입의 메서드가 우선순위가 되는 것이다. 하지만 이 우선순위를 강제로 바꿀 수 있는 방법이 있는데, 이것이 &lt;strong&gt;메서드 오버라이딩&lt;/strong&gt;이다. 자식 타입 클래스에서 메서드 오버라이딩을 하는 순간, 메서드 호출 시 오버라이딩된 타입의 메서드가 최우선순위가 된다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이 두 핵심 이론을 통해 변화에 용이한 객체 지향 설계, 즉 역할과 구현이 분리된 설계가 가능해진다. 부모 타입이 역할, 자식 타입이 구현이라고 생각해보자. 부모 타입으로 특정 메서드를 실행하지만, 자식 타입의 메서드가 호출되는 것. &lt;/p&gt;
&lt;h3&gt;SOLID 법칙&lt;/h3&gt;</content:encoded></item><item><title><![CDATA[🎇 1. About gatsby-starter-hoodie]]></title><description><![CDATA[About gatsby-starter-hoodie gatsby-starter-hoodie is a gatsby theme created for writing tech blogs. Markdown, Code Highlighting in various…]]></description><link>https://aidenroh.github.io/about-hoodie/</link><guid isPermaLink="false">https://aidenroh.github.io/about-hoodie/</guid><pubDate>Sat, 01 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;About gatsby-starter-hoodie&lt;/h2&gt;
&lt;p&gt;gatsby-starter-hoodie is a gatsby theme created for writing tech blogs. Markdown, Code Highlighting in various programming languages, and Katex syntax are supported. Also, you can easily categorize articles into tags and series.&lt;/p&gt;
&lt;p&gt;Start your blog with a neatly designed gatsby-starter-hoodie that supports dark mode.&lt;/p&gt;
&lt;h2&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Markdown&lt;/li&gt;
&lt;li&gt;Code Highlighting&lt;/li&gt;
&lt;li&gt;Katex Syntax&lt;/li&gt;
&lt;li&gt;Dark Mode (Responsive to the settings of the OS)&lt;/li&gt;
&lt;li&gt;Tag Categoriazation&lt;/li&gt;
&lt;li&gt;Series Categorization&lt;/li&gt;
&lt;li&gt;Responsive Web&lt;/li&gt;
&lt;li&gt;SEO&lt;/li&gt;
&lt;li&gt;Utterance (Comment widget)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Let&apos;s get started&lt;/h2&gt;
&lt;p&gt;Follow the &lt;a href=&quot;/quick-start&quot;&gt;Quick Start&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>