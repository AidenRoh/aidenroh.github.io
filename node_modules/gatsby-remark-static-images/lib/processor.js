"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _himalaya = require("himalaya");

var _isRelativeUrl = _interopRequireDefault(require("is-relative-url"));

var _path = _interopRequireDefault(require("path"));

var _slash = _interopRequireDefault(require("slash"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const processStaticImages = async ({
  files,
  markdownAST,
  markdownNode,
  pathPrefix,
  getNode
}, options) => {
  const imageNodes = (0, _utils.getNodes)(markdownAST, 'image');
  const htmlNodes = (0, _utils.getNodes)(markdownAST, 'html');
  const parentNode = getNode(markdownNode.parent);

  if (!parentNode || !parentNode.dir) {
    return;
  }

  const getFileNode = url => {
    const imagePath = (0, _slash.default)(_path.default.resolve(parentNode.dir, url));
    return files.find(file => file.absolutePath === imagePath);
  };

  const processImage = (imagePath, outputPath) => {
    return new Promise((resolve, reject) => {
      if (!_fs.default.existsSync(outputPath)) {
        const readStream = _fs.default.createReadStream(imagePath);

        const writeStream = _fs.default.createWriteStream(outputPath);

        readStream.on('error', reject);
        writeStream.on('error', reject);
        writeStream.on('close', resolve);
        return readStream.pipe(writeStream);
      }

      resolve();
    });
  };

  const getFileName = fileNode => {
    var _ref, _options$imageName;

    return (_ref = options === null || options === void 0 ? void 0 : (_options$imageName = options.imageName) === null || _options$imageName === void 0 ? void 0 : _options$imageName.call(options, fileNode)) !== null && _ref !== void 0 ? _ref : `${fileNode.name}-${fileNode.internal.contentDigest}.${fileNode.extension}`;
  };

  const getFilePath = fileNode => {
    return (0, _slash.default)(_path.default.join(pathPrefix || '/', 'static', getFileName(fileNode)));
  };

  const processFileNode = fileNode => {
    const fileName = getFileName(fileNode);

    const imagePath = _path.default.resolve(process.cwd(), 'public/static', fileName);

    return processImage(fileNode.absolutePath, imagePath);
  };

  const processImageNodes = nodes => {
    return nodes.map(async node => {
      if (!(0, _isRelativeUrl.default)(node.url)) {
        return;
      }

      const fileNode = getFileNode(node.url);

      if (!fileNode) {
        return;
      }

      node.url = getFilePath(fileNode);
      return processFileNode(fileNode);
    });
  };

  const processHtmlNodes = nodes => {
    return nodes.flatMap(node => {
      const htmlASTNodes = (0, _himalaya.parse)(node.value);
      const promises = htmlASTNodes.flatMap(htmlAST => (0, _utils.getNodes)(htmlAST, 'element')).filter(element => element.tagName === 'img').map(async imageNode => {
        const src = imageNode.attributes.find(attribute => attribute.key === 'src');

        if (!src) {
          return;
        }

        if (!(0, _isRelativeUrl.default)(src.value)) {
          return;
        }

        const fileNode = getFileNode(src.value);

        if (!fileNode) {
          return;
        }

        src.value = getFilePath(fileNode);
        return processFileNode(fileNode);
      });

      if (promises.length) {
        node.value = (0, _himalaya.stringify)(htmlASTNodes);
      }

      return promises;
    }, []);
  };

  await Promise.all([...processImageNodes(imageNodes), ...processHtmlNodes(htmlNodes)]);
};

var _default = processStaticImages;
exports.default = _default;